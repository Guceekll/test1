Capture – AI Interview Assistant

1) Project Positioning and Goals

Positioning:
An AI interviewer that can be applied to any topic. It simulates real human interview styles and guides the interviewee to clearly articulate key information through a “one question at a time” format.

Goals:
To produce a complete and reusable conversation log for downstream system consumption (we export it to LAD format as required by the other party).

Core Concept:
It’s not casual chatting—it’s purposeful data collection (clear questioning, clean responses, and standardized export).

Typical Use Cases

User research and usability interviews

Job interviews / candidate Q&A

Defect or failure troubleshooting interviews (for both products and equipment)

Project retrospectives and case documentation

Expert knowledge extraction (experience, steps, and key considerations)

3) Technical Architecture & Role Breakdown
Frontend (React / Next.js)

Page Flow: Welcome Page (topic input + recommended questions) → Chat Page (one question–one answer, text/voice input) → Finish Export.

State: session_id, message list (chronological), input state, recording state.

Constraints: Speech-to-text writes only to the input box and does not auto-send; the system asks only one question at a time.

Backend (FastAPI)

Session Management: Generates/maintains session_id, saves turns (order, role, content, timestamp).

Model Invocation: Passes “existing conversation + topic/style” to the model layer to get the next question.

Export: On Finish, returns an export object (with minimal required fields) and maps it to LAD format (field names/time formats adjustable according to LAD specs).

Model Layer (fast-agent)

A lightweight “interview agent”

Input: topic, style, conversation_so_far (text Q/A history)

Output: next_question (only one)

Questioning Strategy: Open → Deep Dive → Converge (no coverage tracking or auto summarization)

4) Interaction Flow (User Perspective)

The user chooses the system’s suggested first question or inputs their own.

The fast-agent generates the next question based on context (single Q&A loop).

User answers.

Steps 2–3 repeat until the user says “end.”

The user clicks Finish, and the backend exports the data (mapped to LAD for downstream use).

7) Our Current “Minimal Export Structure” (Implemented)

This structure matches the field set in the screenshot you provided. Field names/time formats can be modified later to comply with LAD specifications.

Top Level

session_id: string (UUID)

user_id: string (in-app user identifier)

start_time: string (local time string, can be converted to ISO-8601)

end_time: string (local time string, can be converted to ISO-8601)

title: string (title/topic)

summary: string (brief overview)

chat_log: Message[]

Message

role: "user" | "assistant"

content: string (text, allows line breaks; currently not rendered in Markdown)

Sample (Simplified)

{
  "session_id": "123e4567-e89b-12d3-a456-426614174000",
  "user_id": "user_001",
  "start_time": "2025-10-16T09:00:00",
  "end_time": "2025-10-16T09:30:00",
  "title": "Interview with Technician",
  "summary": "Troubleshooting discussion on machine failure.",
  "chat_log": [
    {
      "role": "user",
      "content": "Can you describe the issue?"
    },
    {
      "role": "assistant",
      "content": "The machine stopped after the power fluctuation."
    }
  ]
}


Why export to LAD:

A standardized interface, allowing direct reuse of the existing validation, storage, and analysis pipeline on the other side.

Versioning and compatibility are managed by the LAD specification, avoiding long-term maintenance costs caused by private JSON formats.

Facilitates cross-team collaboration and compliance governance (e.g., encoding, data masking, retention) through unified standards.
