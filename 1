OPENAI_API_KEY=你的key
OPENAI_BASE_URL=http://你的网关地址:端口/v1
FASTAGENT_DEFAULT_MODEL=openai.你的模型名



# backend/main.py  —— 仅用 .env 配置，Fast-Agent 面向对象最简版
from fastapi import FastAPI, HTTPException, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from dotenv import load_dotenv
from typing import Dict, List, Any
from datetime import datetime
import os

from session_utils import (
    user_might_want_to_end,
    has_repeated_answers,
    user_gave_blank_responses,
)
from session_storage import save_session_to_json
from models import SessionData, ChatMessage

# ✅ 只用 Agent/AgentConfig（模型信息走 .env）
from mcp_agent.agents.agent import Agent, AgentConfig

# ---- 加载 .env，供 Fast-Agent 读取 ----
# 需要的环境变量：
#   OPENAI_API_KEY            # 你的网关/代理的 API Key
#   OPENAI_BASE_URL           # 你的 OpenAI 兼容网关，如 http://host:port/v1
#   FASTAGENT_DEFAULT_MODEL   # 如 openai.my_internal_model
load_dotenv()

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ---- 提示词（可在 .env 覆盖）----
SYSTEM_PROMPT_MAIN = os.getenv(
    "SYSTEM_PROMPT_MAIN",
    "你是一个专业的半导体设备故障采访助手。请一步步引导用户描述问题现象、出现时机、相关操作和可能原因。"
)
SYSTEM_PROMPT_SUMMARY = os.getenv("SYSTEM_PROMPT_SUMMARY", "你是一个擅长总结对话的助手。")
SYSTEM_PROMPT_TITLE = os.getenv("SYSTEM_PROMPT_TITLE", "你是一个擅长命名的助手。")

# ---- 会话内存（我们自己维护）----
store: Dict[str, Dict[str, Any]] = {}

class ChatRequest(BaseModel):
    message: str

class ChatResponse(BaseModel):
    reply: str
    show_end_prompt: bool = False

class EndSessionRequest(BaseModel):
    user_id: str

# ---- 极简工厂：只传 name 和 system，模型用 FASTAGENT_DEFAULT_MODEL（来自 .env）----
def make_agent(name: str, system_prompt: str) -> Agent:
    # 不传 llm/model，Fast-Agent 会从环境变量 FASTAGENT_DEFAULT_MODEL 读取默认模型
    return Agent(config=AgentConfig(name=name, system=system_prompt))

chat_agent    = make_agent("interview_agent", SYSTEM_PROMPT_MAIN)
summary_agent = make_agent("summary_agent",   SYSTEM_PROMPT_SUMMARY)
title_agent   = make_agent("title_agent",     SYSTEM_PROMPT_TITLE)

# ---- 工具函数：把 messages 压成纯文本，统一用 agent.run(text) ----
def build_messages(history: List[Dict[str, str]], user_input: str | None, system_prompt: str) -> List[Dict[str, str]]:
    msgs: List[Dict[str, str]] = [{"role": "system", "content": system_prompt}]
    for m in history:
        if m["role"] in ("user", "assistant"):
            msgs.append(m)
    if user_input is not None:
        msgs.append({"role": "user", "content": user_input})
    return msgs

def run_agent(agent: Agent, messages: List[Dict[str, str]]) -> str:
    prompt = "\n".join(f"{m['role']}: {m['content']}" for m in messages)
    out = agent.run(prompt)  # ✅ 最稳：统一走 run(text)
    if isinstance(out, dict):
        for k in ("content", "text", "message", "output"):
            if k in out and out[k]:
                return str(out[k]).strip()
        return str(out).strip()
    return str(getattr(out, "text", out)).strip()

# ---- 路由 ----
@app.post("/chat/{session_id}", response_model=ChatResponse)
async def chat(session_id: str, req: ChatRequest):
    if session_id not in store:
        store[session_id] = {
            "history": [],
            "asked_end": False,
            "answer_log": [],
            "user_inputs": [],
            "user_id": None,
            "start_time": datetime.utcnow(),
        }

    session = store[session_id]
    history: List[Dict[str, str]] = session["history"]
    asked_end = session["asked_end"]
    answer_log: List[str] = session["answer_log"]
    user_inputs: List[str] = session["user_inputs"]

    user_inputs.append(req.message.strip())
    if len(user_inputs) > 3:
        user_inputs.pop(0)

    if not asked_end and user_might_want_to_end(req.message):
        session["asked_end"] = True
        return ChatResponse(reply="看起来您可能想结束采访，请问是否还有其他问题要补充？", show_end_prompt=True)

    if not asked_end and user_gave_blank_responses(user_inputs):
        session["asked_end"] = True
        return ChatResponse(reply="您好像暂时没有更多补充，如果需要，我们可以结束这次采访。", show_end_prompt=True)

    messages = build_messages(history, req.message, SYSTEM_PROMPT_MAIN)
    try:
        answer_text = run_agent(chat_agent, messages)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Fast-Agent 调用失败: {e}")

    history.append({"role": "user", "content": req.message})
    history.append({"role": "assistant", "content": answer_text})

    answer_log.append(answer_text)
    if not asked_end and has_repeated_answers(answer_log):
        session["asked_end"] = True
        return ChatResponse(reply="我注意到我们有些回答已经重复多次，请问是否需要结束本次采访？", show_end_prompt=True)

    return ChatResponse(reply=answer_text)

@app.post("/end_session/{session_id}")
def end_session(session_id: str, req: EndSessionRequest):
    if session_id not in store:
        raise HTTPException(status_code=404, detail="Session not found")

    session = store[session_id]
    session["user_id"] = req.user_id

    messages = session["history"]
    full_chat = "\n".join([f"{m['role']}: {m['content']}" for m in messages])

    try:
        # 总结
        sum_msgs = [
            {"role": "system", "content": SYSTEM_PROMPT_SUMMARY},
            {"role": "user", "content": f"请你总结以下用户与 AI 的采访对话内容，聚焦设备问题描述、排查过程和结论：\n\n{full_chat}\n\n总结："}
        ]
        summary = run_agent(summary_agent, sum_msgs)

        # 标题
        title_msgs = [
            {"role": "system", "content": SYSTEM_PROMPT_TITLE},
            {"role": "user", "content": f"请基于以下采访内容，生成一个简洁明确的中文标题：\n\n{summary}\n\n标题："}
        ]
        title = run_agent(title_agent, title_msgs)

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Fast-Agent 总结/标题失败: {e}")

    chat_log = [ChatMessage(role=m["role"], content=m["content"]) for m in messages]

    session_data = SessionData(
        session_id=session_id,
        user_id=session["user_id"] or "unknown",
        start_time=session["start_time"],
        end_time=datetime.utcnow(),
        summary=summary,
        title=title,
        chat_log=chat_log,
    )

    path = save_session_to_json(session_data)
    return {"message": "Session saved", "file": path, "summary": summary, "title": title}

@app.post("/upload")
async def upload_file(file: UploadFile = File(...)):
    try:
        os.makedirs("uploaded_files", exist_ok=True)
        file_location = f"uploaded_files/{file.filename}"
        with open(file_location, "wb") as f:
            content = await file.read()
            f.write(content)
        return {"message": "File uploaded successfully", "filename": file.filename, "saved_to": file_location}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Upload failed: {str(e)}")
