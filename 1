dr_api.py

# troubleshooter/dr_api.py

from typing import List, Dict, Any, Optional

# æ—¢å­˜ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®šç¾©ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆå…ƒã‚³ãƒ¼ãƒ‰ã«ã¯æ‰‹ã‚’å…¥ã‚Œãªã„ï¼‰
from . import dr_workflow


def _get_app() -> Any:
    """
    dr_workflow ã‹ã‚‰å®Ÿè¡Œç”¨ã® appï¼ˆãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼‰ã‚’å–å¾—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼ã€‚
    - dr_workflow.app ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ã†
    - ãªã‘ã‚Œã° dr_workflow.create_app() ãŒã‚ã‚Œã°ãã‚Œã‚’å‘¼ã¶
    æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã«å¤‰æ›´ã‚’åŠ ãˆãšã«ã€ãªã‚‹ã¹ãè‡ªå‹•ã§æ‹¾ã†ãŸã‚ã®ãƒ­ã‚¸ãƒƒã‚¯ã€‚
    """
    # ãƒ‘ã‚¿ãƒ¼ãƒ³1: dr_workflow å†…ã« app ã¨ã„ã†å¤‰æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆ
    if hasattr(dr_workflow, "app"):
        return getattr(dr_workflow, "app")

    # ãƒ‘ã‚¿ãƒ¼ãƒ³2: create_app() ã¨ã„ã†ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ãŒã‚ã‚‹å ´åˆ
    if hasattr(dr_workflow, "create_app"):
        create_app = getattr(dr_workflow, "create_app")
        if callable(create_app):
            return create_app()

    # ä¸Šè¨˜ã©ã¡ã‚‰ã‚‚ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
    raise RuntimeError(
        "troubleshooter.dr_workflow ã‹ã‚‰å®Ÿè¡Œç”¨ app ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚\n"
        "dr_workflow å†…ã« `app` å¤‰æ•° ã¾ãŸã¯ `create_app()` é–¢æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚"
    )


def run_troubleshooter(
    message: str,
    history: Optional[List[Dict[str, str]]] = None,
) -> str:
    """
    Troubleshooter ã®çµ±ä¸€ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆã€‚
    - message: ä»Šå›ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå…¥åŠ›ã—ãŸè³ªå•ï¼ˆ1ã‚¿ãƒ¼ãƒ³åˆ†ï¼‰
    - history: ã“ã‚Œã¾ã§ã®å¯¾è©±å±¥æ­´ï¼ˆä»»æ„ï¼‰ã€‚ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ:
        [{"role": "user" | "assistant", "content": "..."}, ...]
      â€» main.py ã® history ã¨åŒã˜å½¢å¼ã‚’æƒ³å®šã€‚

    æˆ»ã‚Šå€¤:
        ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸è¿”ã™ãŸã‚ã®ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°çµæœï¼ˆãƒ†ã‚­ã‚¹ãƒˆï¼‰ã€‚
    """
    app = _get_app()

    # ---- ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å…¥åŠ›ã®çµ„ã¿ç«‹ã¦ ----
    # dr_workflow å´ã®ä»•æ§˜ã«åˆã‚ã›ã¦ key ã‚’èª¿æ•´ã—ã¦ãã ã•ã„ã€‚
    # ä¾‹: è³ªå•ã‚’ "question" ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§æ¸¡ã™æƒ³å®šã€‚
    payload: Dict[str, Any] = {
        "question": message,
    }

    # history ã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«ã—ã¦ãŠããŸã„å ´åˆã¯ä¸€ç·’ã«æ¸¡ã™
    # ï¼ˆdr_workflow å´ãŒå¯¾å¿œã—ã¦ã„ã‚Œã°åˆ©ç”¨ã•ã‚Œã‚‹ï¼‰
    if history is not None:
        payload["history"] = history

    # ---- ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å®Ÿè¡Œ ----
    # LangGraph / LangChain ã®ä½¿ã„æ–¹ã«åˆã‚ã›ã¦ invoke / run ç­‰ã‚’é¸æŠ
    # ã“ã“ã§ã¯ .invoke() ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã—ã€ãªã‘ã‚Œã° callable ã¨ã—ã¦ãã®ã¾ã¾å‘¼ã¶ã€‚
    if hasattr(app, "invoke"):
        result = app.invoke(payload)  # type: ignore[attr-defined]
    elif callable(app):
        result = app(payload)
    else:
        raise RuntimeError(
            "å–å¾—ã—ãŸ app ãŒå®Ÿè¡Œå¯èƒ½ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚invoke() ãƒ¡ã‚½ãƒƒãƒ‰ã¾ãŸã¯ã‚³ãƒ¼ãƒ«å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"
        )

    # ---- çµæœã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã‚’å–ã‚Šå‡ºã™ ----
    # å¤šãã®å ´åˆ result ã¯ dict ã‚’æƒ³å®šã€‚
    # ã“ã“ã§ "answer" ã‚­ãƒ¼ã‚’å„ªå…ˆçš„ã«è¦‹ã‚‹ã€‚
    if isinstance(result, dict):
        # dr_workflow ã®å‡ºåŠ›ä»•æ§˜ã«å¿œã˜ã¦ã“ã“ã‚’èª¿æ•´
        # ä¾‹: {"answer": "..."} or {"troubleshooting_report": "..."}
        if "answer" in result:
            return str(result["answer"])
        if "troubleshooting_report" in result:
            return str(result["troubleshooting_report"])
        # ãã‚Œä»¥å¤–ã®å ´åˆã¯ dict å…¨ä½“ã‚’æ–‡å­—åˆ—åŒ–
        return str(result)

    # dict ã§ãªã„å ´åˆã¯ãã®ã¾ã¾æ–‡å­—åˆ—ã«ã—ã¦è¿”ã™
    return str(result)









main.py


from fastapi import FastAPI, HTTPException, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Dict, List, Any
from datetime import datetime
import os

from dotenv import load_dotenv

load_dotenv()

from agent_app import fast  # fast-agent å®ä¾‹ï¼Œé‡Œé¢æœ‰ interview_agent / summary_agent / title_agent

from session_utils import (
    user_might_want_to_end,
    has_repeated_answers,
    user_gave_blank_responses,
)
from session_storage import save_session_to_json
from models import SessionData, ChatMessage, ChatRequest  # â˜… ä» models é‡Œå¸¦ ChatRequest
from troubleshooter.dr_api import run_troubleshooter


# ==========================
# FastAPI åŸºæœ¬è®¾ç½®
# ==========================
app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],        # å¼€å‘æœŸå…ˆæ”¾å¼€ï¼Œä¹‹åå¯ä»¥æ”¶ç´§
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# å†…å­˜ä¸­çš„ session å­˜å‚¨
store: Dict[str, Dict[str, Any]] = {}


# ==========================
# Pydantic æ¨¡å‹ï¼ˆä»…æœ¬æ–‡ä»¶ç”¨ï¼‰
# ==========================
class ChatResponse(BaseModel):
  reply: str
  show_end_prompt: bool = False  # æ˜¯å¦å‘å‰ç«¯æç¤ºâ€œè¦ä¸è¦ç»“æŸé‡‡è®¿â€


class EndSessionRequest(BaseModel):
  user_id: str


# ==========================
# èŠå¤©æ¥å£
# ==========================
@app.post("/chat/{session_id}", response_model=ChatResponse)
async def chat(session_id: str, req: ChatRequest):
  """
  å•è½®èŠå¤©ï¼š
  - è´Ÿè´£ç»´æŠ¤ session çŠ¶æ€ï¼ˆhistory / answer_log / user_inputsï¼‰
  - æ ¹æ®ç”¨æˆ·è¾“å…¥åˆ¤æ–­æ˜¯å¦æç¤ºç»“æŸ
  - è°ƒç”¨ fast-agent çš„ interview_agent è¾“å‡ºå›ç­”
  - æ ¹æ®å›ç­”é‡å¤åº¦å†æ¬¡åˆ¤æ–­æ˜¯å¦æç¤ºç»“æŸ
  """

  # ---------- åˆå§‹åŒ– session ----------
  if session_id not in store:
    store[session_id] = {
      "history": [],        # [{"role": "user", "content": ...}, {"role": "assistant", ...}, ...]
      "asked_end": False,   # æ˜¯å¦å·²ç»æç¤ºè¿‡â€œè¦ä¸è¦ç»“æŸâ€
      "answer_log": [],     # å½’ä¸€åŒ–åçš„å›ç­”æ–‡æœ¬ï¼Œç”¨äºé‡å¤æ£€æµ‹
      "user_inputs": [],    # æœ€è¿‘å‡ æ¬¡ç”¨æˆ·è¾“å…¥ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦ç©ºè¾“å…¥/æ— å“åº”
      "user_id": None,
      "start_time": datetime.utcnow(),
    }

  session = store[session_id]
  history: List[Dict[str, str]] = session["history"]
  answer_log: List[str] = session["answer_log"]
  user_inputs: List[str] = session["user_inputs"]

  # ---------- ç»Ÿä¸€æ¸…æ´—è¾“å…¥ ----------
  raw = req.message if req.message is not None else ""
  msg = raw.strip()
  msg_lc = msg.lower()

  # ç»´æŠ¤æœ€è¿‘ 5 æ¡ç”¨æˆ·è¾“å…¥çª—å£
  user_inputs.append(msg)
  if len(user_inputs) > 5:
    user_inputs.pop(0)

  # ---------- 1) å¤„ç†ç©ºè¾“å…¥/æ— å“åº” ----------
  if not session["asked_end"]:
    if (msg == "") or user_gave_blank_responses(user_inputs):
      session["asked_end"] = True
      return ChatResponse(
        reply="æ‚¨å¥½åƒæš‚æ—¶æ²¡æœ‰æ›´å¤šè¡¥å……ï¼Œå¦‚æœéœ€è¦ï¼Œæˆ‘ä»¬å¯ä»¥ç»“æŸè¿™æ¬¡é‡‡è®¿ã€‚",
        show_end_prompt=True,
      )

  # ---------- 2) æ£€æµ‹ç”¨æˆ·å¯èƒ½æƒ³ç»“æŸ ----------
  if not session["asked_end"] and user_might_want_to_end(msg_lc):
    session["asked_end"] = True
    return ChatResponse(
      reply="çœ‹èµ·æ¥æ‚¨å¯èƒ½æƒ³ç»“æŸé‡‡è®¿ï¼Œè¯·é—®æ˜¯å¦è¿˜æœ‰å…¶ä»–é—®é¢˜è¦è¡¥å……ï¼Ÿ",
      show_end_prompt=True,
    )

  # ---------- 3) è°ƒç”¨ fast-agent ----------
  try:
    async with fast.run() as agent:
            if req.use_troubleshooter:
                # â˜… 1) å…ˆè°ƒç”¨ troubleshooter è·å–æ•…éšœåˆ†æç»“æœ
                ts_report = run_troubleshooter(
                    message=msg,
                    history=history,  # ç›´æ¥å¤ç”¨å½“å‰ session çš„ history
                )

                # â˜… 2) å†æŠŠ troubleshooter çš„ç»“æœ + ç”¨æˆ·é—®é¢˜ï¼Œä¸€èµ·ç»™ interview_agent
                agent_input = (
                    "ã€ä»¥ä¸‹ã¯ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆ†æçµæœã§ã™ã€‚"
                    "ã“ã‚Œã‚’è¸ã¾ãˆã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«åˆ†ã‹ã‚Šã‚„ã™ãå›ç­”ã—ã¦ãã ã•ã„ã€‘\n\n"
                    f"{ts_report}\n\n"
                    "ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä»Šå›ã®è³ªå•ã€‘\n"
                    f"{msg}"
                )
            else:
                # é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ï¼šãã®ã¾ã¾è³ªå•ã ã‘æ¸¡ã™
                agent_input = msg

            answer_text = str(await agent.interview_agent(agent_input)).strip()
  except Exception as e:
    raise HTTPException(status_code=500, detail=f"fast-agent è°ƒç”¨å¤±è´¥: {e}")


  # æŠŠæœ¬è½®å¯¹è¯å†™å…¥ history
  history.append({"role": "user", "content": msg})
  history.append({"role": "assistant", "content": answer_text})

  # æ ‡å‡†åŒ–å›ç­”åå†™å…¥ answer_logï¼Œç”¨äºé‡å¤æ£€æµ‹
  norm_ans = " ".join(answer_text.lower().split())
  answer_log.append(norm_ans)

  # ---------- 4) é‡å¤å›ç­”æ£€æµ‹ ----------
  if not session["asked_end"] and has_repeated_answers(answer_log):
    session["asked_end"] = True
    return ChatResponse(
      reply="æˆ‘æ³¨æ„åˆ°æˆ‘ä»¬æœ‰äº›å›ç­”å·²ç»é‡å¤å¤šæ¬¡ï¼Œè¯·é—®æ˜¯å¦éœ€è¦ç»“æŸæœ¬æ¬¡é‡‡è®¿ï¼Ÿ",
      show_end_prompt=True,
    )

  # é»˜è®¤æ­£å¸¸è¿”å›å›ç­”
  return ChatResponse(reply=answer_text)


# ==========================
# ç»“æŸ session + æ€»ç»“ & ä¿å­˜
# ==========================
@app.post("/end_session/{session_id}")
async def end_session(session_id: str, req: EndSessionRequest):
  if session_id not in store:
    raise HTTPException(status_code=404, detail="Session not found")

  session = store[session_id]
  session["user_id"] = req.user_id
  history: List[Dict[str, str]] = session["history"]

  # æŠŠæ•´åœºèŠå¤©æ‹¼æˆåŸå§‹æ–‡æœ¬ï¼Œäº¤ç»™ summary_agent
  full_chat = "\n".join(
    f"{'ç”¨æˆ·' if m['role'] == 'user' else 'åŠ©æ‰‹'}: {m['content']}"
    for m in history
  )

  try:
    async with fast.run() as agent:
      summary = str(await agent.summary_agent(full_chat)).strip()
      title = str(await agent.title_agent(summary)).strip()
  except Exception as e:
    raise HTTPException(status_code=500, detail=f"fast-agent æ€»ç»“/æ ‡é¢˜å¤±è´¥: {e}")

  # æ„é€  SessionData å¹¶æŒä¹…åŒ–
  chat_log = [ChatMessage(role=m["role"], content=m["content"]) for m in history]

  session_data = SessionData(
    session_id=session_id,
    user_id=session["user_id"] or "unknown",
    start_time=session["start_time"],
    end_time=datetime.utcnow(),
    summary=summary,
    title=title,
    chat_log=chat_log,
  )

  path = save_session_to_json(session_data)

  return {
    "message": "Session saved",
    "file": path,
    "summary": summary,
    "title": title,
  }


# ==========================
# æ–‡ä»¶ä¸Šä¼ ï¼ˆä¾›å‰ç«¯å‘é€æ–‡ä»¶ï¼‰
# ==========================
@app.post("/upload")
async def upload_file(file: UploadFile = File(...)):
  try:
    os.makedirs("uploaded_files", exist_ok=True)
    file_location = f"uploaded_files/{file.filename}"
    with open(file_location, "wb") as f:
      content = await file.read()
      f.write(content)

    return {
      "message": "File uploaded successfully",
      "filename": file.filename,
      "saved_to": file_location,
    }
  except Exception as e:
    raise HTTPException(status_code=500, detail=f"Upload failed: {str(e)}")





model.py

from pydantic import BaseModel
from typing import List
from datetime import datetime

class ChatMessage(BaseModel):
    role: str
    content: str

class SessionData(BaseModel):
    session_id: str
    user_id: str
    start_time: datetime
    end_time: datetime
    summary: str
    title: str 
    chat_log: List[ChatMessage]

class ChatRequest(BaseModel):
    message: str
    use_troubleshooter: bool = False



inter/page.tsx


'use client';

import { useParams, useSearchParams } from 'next/navigation';
import { useState, useEffect, useRef } from 'react';
import Sidebar from '@/components/Sidebar';
import ChatWindow from '@/components/ChatWindow';
import InputPanel from '@/components/InputPanel';
import Header from '@/components/Header';

interface Message {
  type: 'question' | 'answer' | 'loading';
  text: string;
  summary?: boolean;
  fileName?: string;
  fileType?: string;
}

export default function InterviewPage() {
  const { sessionId } = useParams();
  const searchParams = useSearchParams();
  const qParam = searchParams.get('q');

  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [finished, setFinished] = useState(false);
  const [summary, setSummary] = useState('');
  const [saving, setSaving] = useState(false);
  const sentOnceRef = useRef(false);

  // â˜… Troubleshooter å¼€å…³çŠ¶æ€
  const [useTroubleshooter, setUseTroubleshooter] = useState(false);

  useEffect(() => {
    if (qParam && !sentOnceRef.current) {
      sentOnceRef.current = true;
      setInput(qParam);
      handleSend(qParam);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [qParam]);

  const handleSend = async (question?: string, file?: File) => {
    const text = question ?? input;
    if (!text.trim() && !file) return;

    // 1. å…ˆå¤„ç†æ–‡ä»¶ä¸Šä¼ 
    if (file) {
      const formData = new FormData();
      formData.append('file', file);

      try {
        await fetch('http://localhost:8000/upload', {
          method: 'POST',
          body: formData,
        });

        // âœ… æ·»åŠ æ–‡ä»¶æ¶ˆæ¯
        setMessages((prev) => [
          ...prev,
          {
            type: 'question',
            text: '',
            fileName: file.name,
            fileType: file.type?.split('/')[1] || 'file',
          },
        ]);
      } catch (error) {
        console.error('Upload failed:', error);
        setMessages((prev) => [
          ...prev,
          { type: 'answer', text: 'âŒ æ–‡ä»¶ä¸Šä¼ å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ã€‚' },
        ]);
        return;
      }
    }

    // 2. å¤„ç†æ–‡æœ¬è¾“å…¥
    if (text.trim()) {
      setMessages((prev) => [...prev, { type: 'question', text }]);
      setInput('');
      setMessages((prev) => [...prev, { type: 'loading', text: '...' }]);

      try {
        const res = await fetch(`http://localhost:8000/chat/${sessionId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: text,
            // â˜… æŠŠå¼€å…³çŠ¶æ€ä¼ ç»™åç«¯
            use_troubleshooter: useTroubleshooter,
          }),
        });

        const data = await res.json();

        setMessages((prev) => {
          const newMessages = [...prev];
          const idx = newMessages.findIndex((msg) => msg.type === 'loading');
          if (idx !== -1) {
            newMessages[idx] = { type: 'answer', text: data.reply };
          } else {
            newMessages.push({ type: 'answer', text: data.reply });
          }
          return newMessages;
        });
      } catch (error) {
        setMessages((prev) => {
          const newMessages = [...prev];
          const idx = newMessages.findIndex((msg) => msg.type === 'loading');
          if (idx !== -1) {
            newMessages[idx] = {
              type: 'answer',
              text: 'âš ï¸ å‡ºé”™äº†ï¼Œæ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ã€‚',
            };
          } else {
            newMessages.push({
              type: 'answer',
              text: 'âš ï¸ å‡ºé”™äº†ï¼Œæ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ã€‚',
            });
          }
          return newMessages;
        });
      }
    }
  };

  const handleFinish = async () => {
    if (saving || finished) return;
    setSaving(true);

    setMessages((prev) => [
      ...prev,
      { type: 'loading', text: 'ğŸ“„ æ€»ç»“ç”Ÿæˆä¸­ï¼Œè¯·ç¨å€™...' },
    ]);

    try {
      const res = await fetch(
        `http://localhost:8000/end_session/${sessionId}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user_id: 'user001',
          }),
        }
      );

      const data = await res.json();
      setSummary(data.summary);

      setMessages((prev) => {
        const newMessages = [...prev];
        const idx = newMessages.findIndex(
          (msg) =>
            msg.type === 'loading' && msg.text.includes('æ€»ç»“ç”Ÿæˆä¸­')
        );
        if (idx !== -1) {
          newMessages[idx] = {
            type: 'answer',
            text: `âœ… é‡‡è®¿å·²ç»“æŸã€‚ä»¥ä¸‹æ˜¯æ€»ç»“ï¼š\n\n${data.summary}`,
            summary: true,
          };
        } else {
          newMessages.push({
            type: 'answer',
            text: `âœ… é‡‡è®¿å·²ç»“æŸã€‚ä»¥ä¸‹æ˜¯æ€»ç»“ï¼š\n\n${data.summary}`,
            summary: true,
          });
        }
        return newMessages;
      });

      setFinished(true);
    } catch (error) {
      setMessages((prev) => [
        ...prev,
        { type: 'answer', text: 'âš ï¸ ä¿å­˜å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ã€‚' },
      ]);
    } finally {
      setSaving(false);
    }
  };

  return (
    <div className="flex h-screen">
      <Sidebar
        onNewChat={() => (window.location.href = '/')}
        onSelectCategory={(cat) => console.log('Category selected:', cat)}
        onSelectRecentChat={(title) => console.log('Chat selected:', title)}
      />
      <div className="flex flex-col flex-1 bg-white">
        {/* â˜… ç»Ÿä¸€çš„é¡¶éƒ¨æ  */}
        <Header
          title="ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼"
          useTroubleshooter={useTroubleshooter}
          onToggle={() => setUseTroubleshooter((prev) => !prev)}
        />

        {/* èŠå¤©çª—å£ */}
        <ChatWindow messages={messages} />

        {/* åº•éƒ¨è¾“å…¥æ¡† */}
        <InputPanel
          value={input}
          onChange={setInput}
          onSend={(text, file) => handleSend(text, file)}
          onUpload={(file) => handleSend(undefined, file)}
          onFinish={handleFinish}
          showFinish={true}
          isFinishing={saving}
        />
      </div>
    </div>
  );
}







app/page.tsx

'use client';

import { useRouter } from 'next/navigation';
import { v4 as uuidv4 } from 'uuid';
import { useEffect, useState } from 'react';
import Sidebar from '@/components/Sidebar';
import Welcome from '@/components/Welcome';
import InputPanel from '@/components/InputPanel';
import Header from '@/components/Header';  // â˜… æ–°å¢ï¼šç»Ÿä¸€çš„é¡¶éƒ¨æ ç»„ä»¶

const promptPool = [
  'Handler is stuck. What should I do?',
  'Why is the alignment always off?',
  'Etcher shows vacuum alarm. How to fix it?',
  "CVD can't reach target temp. Possible causes?",
  'Load lock has a leak warning. What now?',
  "Robot can't pick up wafers.",
  'Coating thickness is uneven. How to adjust?',
  'PVD says target is worn out. What next?',
  'Edge defects keep appearing. Any ideas?',
  'Recipe froze during run. How do I recover?',
];

export default function HomePage() {
  const router = useRouter();
  const [input, setInput] = useState('');
  const [prompts, setPrompts] = useState<string[]>([]);
  const [useTroubleshooter, setUseTroubleshooter] = useState(false); // ä¸»é¡µä¹Ÿæœ‰ TS å¼€å…³

  useEffect(() => {
    const shuffled = [...promptPool].sort(() => 0.5 - Math.random());
    setPrompts(shuffled.slice(0, 3));
  }, []);

  const startInterview = (question: string) => {
    if (!question.trim()) return;
    const sessionId = uuidv4();
    const tsFlag = useTroubleshooter ? '1' : '0'; // å…ˆå¸¦åœ¨ URL é‡Œï¼Œä¹‹å Interview é¡µæƒ³ç”¨ä¹Ÿæ–¹ä¾¿
    router.push(
      `/interview/${sessionId}?q=${encodeURIComponent(question)}&ts=${tsFlag}`,
    );
  };

  return (
    <div className="flex h-screen">
      <Sidebar
        onNewChat={() => router.push('/')}
        onSelectCategory={(cat) => console.log('åˆ†ç±»:', cat)}
        onSelectRecentChat={(chat) => console.log('èŠå¤©:', chat)}
      />

      {/* å³ä¾§ä¸»åŒºåŸŸ */}
      <div className="flex flex-col flex-1 bg-white">
        {/* é¡¶éƒ¨æ ‡é¢˜ + Troubleshooter å¼€å…³ï¼ˆç”¨ Header ç»„ä»¶ï¼Œå’Œ Interview é¡µå®Œå…¨ä¸€è‡´ï¼‰ */}
        <Header
          title="ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼"
          useTroubleshooter={useTroubleshooter}
          onToggle={() => setUseTroubleshooter((prev) => !prev)}
        />

        {/* ä¸­é—´ Welcome + æ¨èé—®é¢˜ + åº•éƒ¨è¾“å…¥æ¡† */}
        <div className="relative flex-1 flex flex-col items-center justify-center text-center">
          <Welcome onSelectQuestion={startInterview} />

          {/* æ¨èé—®é¢˜æŒ‰é’® */}
          <div className="absolute bottom-[96px] w-full flex justify-center gap-2">
            {prompts.map((q, i) => (
              <button
                key={i}
                onClick={() => startInterview(q)}
                className="px-4 py-2 border border-blue-300 rounded-lg text-sm hover:bg-blue-50 bg-white"
              >
                {q}
              </button>
            ))}
          </div>

          {/* åº•éƒ¨è¾“å…¥æ¡† */}
          <div className="absolute bottom-0 w-full">
            <InputPanel
              value={input}
              onChange={setInput}
              onSend={() => startInterview(input)}
              onUpload={() => console.log('ä¸Šä¼ ')}
              showFinish={false}
            />
          </div>
        </div>
      </div>
    </div>
  );
}





compon

chatwidown


'use client';

import { useEffect, useRef } from 'react';

interface Message {
  type: 'question' | 'answer' | 'loading';
  text: string;
  summary?: boolean;
  fileName?: string;
  fileType?: string;
}

interface ChatWindowProps {
  messages: Message[];
}

export default function ChatWindow({ messages }: ChatWindowProps) {
  const bottomRef = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  return (
    <div className="flex-1 overflow-y-auto px-4 py-6 space-y-4 bg-white">
      {messages.map((msg, idx) => {
        const isUser = msg.type === 'question';

        return (
          <div
            key={idx}
            className={`flex ${isUser ? 'justify-end' : 'justify-start'}`}
          >
            <div
              className={`max-w-[70%] px-4 py-2 rounded-2xl text-sm whitespace-pre-wrap
                ${msg.type === 'question' ? 'bg-blue-500 text-white' : ''}
                ${
                  msg.type === 'answer' && msg.summary
                    ? 'bg-green-100 text-green-800 border border-green-400'
                    : ''
                }
                ${
                  msg.type === 'answer' && !msg.summary
                    ? 'bg-gray-200 text-gray-800'
                    : ''
                }
                ${
                  msg.type === 'loading'
                    ? 'bg-gray-100 text-gray-500 animate-pulse'
                    : ''
                }
              `}
            >
              {/* âœ… æ¸²æŸ“æ–‡ä»¶å¡ç‰‡ */}
              {msg.fileName ? (
                <div className="flex items-center gap-3 bg-pink-100 rounded-xl px-3 py-2 w-fit shadow-sm border border-pink-200">
                  <div className="flex flex-col text-sm max-w-[180px]">
                    <span className="font-medium text-gray-800 truncate">
                      {msg.fileName}
                    </span>
                    <span className="text-xs text-gray-500">
                      {msg.fileType?.toUpperCase() || 'FILE'}
                    </span>
                  </div>
                </div>
              ) : (
                msg.text
              )}
            </div>
          </div>
        );
      })}
      <div ref={bottomRef} />
    </div>
  );
}






Header.tsx


'use client';

interface HeaderProps {
  title: string;
  useTroubleshooter: boolean;
  onToggle: () => void;
}

export default function Header({ title, useTroubleshooter, onToggle }: HeaderProps) {
  return (
    <div className="h-14 border-b border-gray-300 bg-[#FFFAF2] flex items-center justify-between px-6">
      {/* å·¦ä¾§æ ‡é¢˜ */}
      <h1 className="text-xl font-bold text-gray-800">{title}</h1>

      {/* å³ä¾§ Troubleshooter å¼€å…³ */}
      <div
        onClick={onToggle}
        className="flex items-center gap-2 px-4 py-2 bg-gray-100 rounded-full cursor-pointer border hover:bg-gray-200"
      >
        <span
          className={`w-3 h-3 rounded-full ${
            useTroubleshooter ? 'bg-green-500' : 'bg-gray-400'
          }`}
        />
        <span className="font-medium text-gray-600">
          Troubleshooterï¼š {useTroubleshooter ? 'ON' : 'OFF'}
        </span>
      </div>
    </div>
  );
}





input



'use client';

import { useRef, useState } from 'react';

interface InputPanelProps {
  value: string;
  onChange: (val: string) => void;
  onSend: (text: string, file?: File) => void;
  onUpload?: (file: File) => void;
  onFinish?: () => void;
  showFinish?: boolean;
  isFinishing?: boolean;
}

const InputPanel = ({
  value,
  onChange,
  onSend,
  onFinish,
  showFinish = true,
  isFinishing = false,
}: InputPanelProps) => {
  const fileInputRef = useRef<HTMLInputElement | null>(null);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);

  const handleKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      triggerSend();
    }
  };

  const triggerSend = () => {
    if (!value.trim() && !selectedFile) return;
    onSend(value, selectedFile || undefined);
    onChange('');
    setSelectedFile(null);
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setSelectedFile(file);
    }
  };

  return (
    <div className="w-full px-4 py-3 border-t border-gray-200 bg-white flex justify-center">
      <div className="w-full max-w-4xl flex flex-col gap-3">
        {/* æ–‡ä»¶å¡ç‰‡ */}
        {selectedFile && (
          <div className="flex items-center gap-3 bg-pink-100 rounded-xl px-4 py-3 w-fit shadow-sm border border-pink-200">
            <div className="flex flex-col text-sm max-w-[200px]">
              <span className="font-semibold text-gray-800 truncate">{selectedFile.name}</span>
              <span className="text-gray-500 text-xs">
                {selectedFile.type?.split('/')[1]?.toUpperCase() || 'FILE'}
              </span>
            </div>

            <button
              onClick={() => setSelectedFile(null)}
              className="ml-2 text-gray-500 hover:text-gray-800 rounded-full p-1 transition"
              title="Remove file"
            >
              <svg
                className="h-4 w-4"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d="M6 18L18 6M6 6l12 12"
                />
              </svg>
            </button>
          </div>
        )}

        {/* è¾“å…¥æ¡† + Finish æŒ‰é’®åŒä¸€è¡Œ */}
        <div className="flex items-center gap-2">
          <div className="flex items-center flex-1 px-4 py-2 border border-black rounded-full shadow bg-gradient-to-b from-white to-gray-50">
            <button
              onClick={() => fileInputRef.current?.click()}
              className="text-xl text-gray-500"
              title="Upload file"
            >
              ğŸ“
            </button>

            <input
              type="file"
              ref={fileInputRef}
              className="hidden"
              onChange={handleFileChange}
            />

            <input
              type="text"
              value={value}
              onChange={(e) => onChange(e.target.value)}
              onKeyDown={handleKeyPress}
              placeholder="type your trouble here"
              className="flex-1 px-4 bg-transparent border-none focus:outline-none text-gray-800 placeholder-gray-400"
            />

            <button className="text-xl mx-2" title="Voice input (coming soon)">ğŸ¤</button>

            <button
              onClick={triggerSend}
              className="w-10 h-10 rounded-full bg-blue-500 flex items-center justify-center text-white text-lg"
              title="Send"
            >
              â¤
            </button>
          </div>

          {showFinish && (
            <button
              onClick={onFinish}
              disabled={isFinishing}
              className={`flex-shrink-0 px-4 py-2 rounded-lg text-sm transition ${
                isFinishing
                  ? 'bg-gray-200 text-gray-500 cursor-not-allowed'
                  : 'bg-gray-300 hover:bg-gray-400'
              }`}
              title="Finish this interview"
            >
              {isFinishing ? 'Generating...' : 'Finish'}
            </button>
          )}
        </div>
      </div>
    </div>
  );
};

export default InputPanel;
