# troubleshooter/dr_api.py
# ============================================================
# Deep Research トラブルシューティング用の薄いラッパーモジュール
# ・他モジュール（main.py など）からは run_troubleshooter() だけを呼び出せばよい
# ・実際のワークフロー実行は dr_workflow.run_troubleshooting() に委譲する
# ============================================================

from typing import List, Dict, Any, Optional

# 既存のワークフロー入口関数をインポート（※ dr_workflow 自体は変更しない）
from .dr_workflow import run_troubleshooting


def run_troubleshooter(
    message: str,
    history: Optional[List[Dict[str, str]]] = None,
) -> str:
    """
    Troubleshooter の統一エントリポイント。

    Parameters
    ----------
    message : str
        今回ユーザーが入力した質問テキスト（1ターン分）。
    history : Optional[List[Dict[str, str]]]
        これまでの対話履歴（任意）。
        形式は main.py の history と同じ
        [{'role': 'user' | 'assistant', 'content': '...'}, ...] を想定。

    Returns
    -------
    str
        ユーザーへ返すためのトラブルシューティング結果テキスト。
    """
    try:
        # ----------------------------------------------------
        # dr_workflow.run_troubleshooting に処理を委譲する
        #   user_input には今回の message をそのまま渡す。
        #   （必要であれば、ここで history を使って事前要約するなども可能）
        # ----------------------------------------------------
        final_state: Any = run_troubleshooting(message)

        # final_state は TroubleState(dict) を想定しているので、
        # dict として扱って出力フィールドを取り出す。
        if isinstance(final_state, dict):
            # dr_nodes.py の仕様に合わせて優先順位を付ける
            text = (
                final_state.get("optimizer_answer")
                or final_state.get("report")
                or ""
            )
        else:
            text = final_state

        if not isinstance(text, str):
            text = str(text)

        return text

    except Exception:
        # ここで例外を握りつぶし、バックエンド全体が 500 にならないようにする
        print("=== run_troubleshooter で例外発生 ===")
        import traceback
        traceback.print_exc()
        print("=== 例外ここまで ===")

        # 失敗した時はフォールバック用メッセージを返す
        return "【トラブルシューティングモジュールでエラーが発生しました。今回は通常の回答フローのみを利用します。】"
